from flask import session, abort, current_app, request
from flask.ext.security import current_user

from wimoto.core import http
from wimoto.core.decorators import api_resource
from wimoto.core.resources import Resource
from wimoto.core.utils import jsonify_status_code
from wimoto.account.models import Customer
from wimoto.product.models import Cart, Order
from wimoto.product.datastore import CartDatastore

from wimoto.utils.api import BaseMongoResource, GetOnlyMixin

from . import delivery
from .documents import DeliveryProvider

from suds.client import Client
from datetime import datetime, timedelta


__all__ = ['DeliveryProviderResource', 'GlsResource']


def _get_customer():
    if current_user.is_anonymous():
        customer_id = session.get('customer_id')

        if customer_id is not None:
            customer = Customer.query.get(customer_id)
        else:
            abort(http.BAD_REQUEST)
    else:
        customer = current_user.customer

    return customer


@api_resource(delivery, 'provider', {'id': None})
class DeliveryProviderResource(BaseMongoResource):

    model = DeliveryProvider

    def post(self):
        abort(http.METHOD_NOT_ALLOWED)

    def put(self):
        abort(http.METHOD_NOT_ALLOWED)

    def delete(self):
        abort(http.METHOD_NOT_ALLOWED)

    @classmethod
    def serialize(cls, instance, include=None):
        """ Method to controls model serialization in derived classes
        :rtype : dict
        """
        data = instance.as_dict(include, exclude=['regions'])
        customer = _get_customer()
        address = customer.delivery_address
        goods_ds = CartDatastore(Cart)
        goods = goods_ds.find(customer=customer, is_ordered=False)
        data['price'] = instance.calculate_price(goods, address)
        return data

    def get_objects(self, **kwargs):
        customer = _get_customer()
        address = customer.delivery_address
        exclude_ids = []

        # Exclude all providers that is not correspond to user delivery address
        if address is not None:
            for provider in self.model.query.all():
                if provider.get_region(address.country_id) is None:
                    exclude_ids.append(provider._id)

        kwargs['_id'] = {'$not': {'$in': exclude_ids}}

        return self._filters_map(kwargs)


@api_resource(delivery, 'gls', {'id': None})
class GlsResource(GetOnlyMixin, Resource):
    __provider = current_app.config['DELIVERY_PROVIDERS']['gls']

    def _gls_datetime(self, dt):
        gls_datetime = self.gls.factory.create('GLSDateTime')

        gls_datetime.Year = dt.year
        gls_datetime.Month = dt.month
        gls_datetime.Day = dt.day
        gls_datetime.Hour = dt.hour
        gls_datetime.Minut = dt.minute

        return gls_datetime

    @classmethod
    def as_dict(cls, instance, instance_type=None):
        if instance is None:
            return None
        if type(instance) == instance_type:
            result = {}
            for item in instance:
                if item is None:
                    continue
                result[item[0]] = cls.as_dict(item[1], instance_type)
            return result
        elif type(instance) in (list, tuple):
            return [cls.as_dict(i, instance_type) for i in instance if type(i) is not None]
        else:
            return instance

    @classmethod
    def serialize(cls, instance):
        instance_type = type(instance)
        result = {}
        for item in instance:
            if item is not None:
                result[item[0]] = cls.as_dict(item[1], instance_type)
                if item[0] == 'RefNo':
                    result['id'] = cls.as_dict(item[1], instance_type)
        return result

    def get_objects(self, **kwargs):
        from_date = request.args.get('from')
        until_date = request.args.get('until')
        custom_ref = request.args.get('custom_ref')
        ref_value = request.args.get('ref_value')
        order_id = request.args.get('order_id')

        if until_date is None:
            until_date = datetime.utcnow()
        if from_date is None:
            from_date = until_date - timedelta(days=7)

        from_date = self._gls_datetime(from_date)
        until_date = self._gls_datetime(until_date)

        if order_id is not None:
            from wimoto.shop.models import Shop
            order = Order.query.get(order_id)
            if order is None:
                return []
            shop = Shop.query.get(order.shop_id)
            custom_ref = '%s-%i' % (shop.shop_name, order.id)

        kwargs.update({
            'Credentials': self.__gls_user,
            'DateFrom': from_date,
            'DateTo': until_date
        })
        if custom_ref is not None:
            kwargs['CustomRef'] = custom_ref
        if ref_value is not None:
            kwargs['RefValue'] = ref_value

        response = self.gls.service.GetTuList(**kwargs)
        return response.TUList

    def get_object(self, id):
        kwargs = {
            'Credentials': self.__gls_user,
            'RefValue': id
        }
        response = self.gls.service.GetTuDetail(**kwargs)

        return response


    def get(self, id=None):
        status = http.OK
        self.gls = Client(self.__provider['wsdl']['scheme'])
        self.__gls_user = self.gls.factory.create('GLSUserCredentials')
        self.__gls_user.UserName = self.__provider['wsdl']['user']
        self.__gls_user.Password = self.__provider['wsdl']['pass']

        if id is None:
            response = self.get_objects()
            response = {'objects': [self.serialize(item) for item in response]}
        else:
            response = self.serialize(self.get_object(id))
            response['id'] = id
        return jsonify_status_code(response, status)

from datetime import datetime

from flask.ext.security import roles_required
#from flask import current_app
from flask.ext.babel import lazy_gettext as _

from sqlalchemy import or_

from wimoto.core import db
from wimoto.core.decorators import api_resource
from wimoto.core.resources import ModelResource
from wimoto.core.utils import jsonify_status_code
from wimoto.account.models import Customer
# from wimoto.account.api import CustomerResource
from wimoto.discount.models import (Discount, Discount_x_Customer,
                                    Discount_x_Category)
from wimoto.product.models import Category

from wimoto.utils.api import admin_role
from werkzeug.exceptions import BadRequest

import trafaret as t

from . import (CATEGORY_CHOICE,
               USER_CHOICE,
               PRODUCT_CHOICE,
               CART_CHOICE,
               PERCENT_CHOICE,
               CURRENCY_CHOICE,
               discount)

from flask import request


__all__ = ['DiscountResource', 'DiscountCustomerResource',
           'DiscountCategoryResource']


@api_resource(discount, 'groups', {'id': None})
class DiscountResource(ModelResource):
    model = Discount

    method_decorators = {
        'post': [roles_required(admin_role)],
        'put': [roles_required(admin_role)],
        'delete': [roles_required(admin_role)]
    }

    validation = t.Dict({
        "group_name": t.String,
        "discount_type": t.Enum(CURRENCY_CHOICE, PERCENT_CHOICE),
        "amount":t.Float,
        "group_type": t.Enum(CATEGORY_CHOICE, USER_CHOICE, PRODUCT_CHOICE, CART_CHOICE),
        "date_from": t.DateTime,
        "date_to": t.DateTime,
        "shop_id": t.Int,
        t.Key('free_delivery', default=False): t.Bool,
        "min_value": t.Float
        }).ignore_extra('*').make_optional("date_from", "date_to", "min_value")

    def get_objects(self, **kwargs):
        """ Method for extraction object list query
        """
        order_map = {'group_name': Discount.group_name,
                     'group_type': Discount.group_type,
                     'amount': Discount.amount,
                     'discount_type':Discount.discount_type}
        enum = [
            CATEGORY_CHOICE,
            USER_CHOICE,
            PRODUCT_CHOICE,
            CART_CHOICE,
            PERCENT_CHOICE,
            CURRENCY_CHOICE
        ]
        group_type = request.args.get('group_type')
        if group_type is not None and group_type in enum:
            kwargs['group_type'] = group_type

        query = self.model.query.filter_by(**kwargs)

        if 'q' in request.args and request.args['q']:

            q = request.args['q']
            q = "%"+q+"%"
            search_filters = Discount.group_name.ilike(q)

            query = query.filter(search_filters)

        if 'o' in request.args:
            try:
                order_field = order_map[request.args['o']]
            except KeyError, e:
                raise BadRequest(u"Unsupported attribute value: o=%s" % e)

            ot = request.args.get('ot', 'asc')
            if ot == 'desc':
                order_field = order_field.desc()

            query = query.order_by(order_field)
        else:
            query = query.order_by(order_map['group_name'])

        return query

    def clean(self, data):
        if 'date_from' in data:
            date = data['date_from'].split('-')
            count_date = len([x for x in date if x!=''])
            if (count_date != 0 and count_date != 3):
                raise t.DataError({'date_from': _('incorrect format')})
            if (count_date == 0):
                data.pop('date_from')

        if 'date_to' in data:
            date = data['date_to'].split('-')
            count_date = len([x for x in date if x!=''])
            if (count_date != 0 and count_date != 3):
                raise t.DataError({'date_to': _('incorrect format')})
            if (count_date == 0):
                data.pop('date_to')

        # TODO: change comparison
        if ('date_from' in data) and ('date_to' in data):
            try:
                date_from = datetime.strptime(data["date_from"], "%Y-%m-%d")
            except ValueError, err:
                raise t.DataError({'date_from': err.message})
            try:
                date_to = datetime.strptime(data["date_to"], "%Y-%m-%d")
            except ValueError, err:
                raise t.DataError({'date_to': err.message})

            if date_from > date_to:
                raise t.DataError({'date_to': _('range is incorrect')})
        data = super(DiscountResource, self).clean(data)

        return data

    def delete(self, id):
        Discount_x_Customer.query.filter_by(discount_id=id).delete()
        Discount_x_Category.query.filter_by(discount_id=id).delete()
        return super(DiscountResource, self).delete(id)


@api_resource(discount, 'customer', {'id': None})
class DiscountCustomerResource(ModelResource):
    model = Discount_x_Customer

    method_decorators = {
        'post': [roles_required(admin_role)],
        'put': [roles_required(admin_role)],
        'delete': [roles_required(admin_role)]
    }

    validation = t.Dict({
        "discount_id": t.Int,
        "customer_id":t.Int})

    def get(self, id=None):
        if id is None:
            response = self.gen_list_response()
            response = self.make_response(response)
        else:
            response = self.serialize(self.get_object(id))
            if response:
                response.update(self.get_params(response['customer_id']))
        return jsonify_status_code(response)

    def make_response(self, response):
        for object in response["objects"]:
            object.update(self.get_params(object['customer_id']))
        return response

    def get_params(self, customer_id):
        result = dict()
        customer = Customer.query.filter_by(id=customer_id).first().as_dict()
        if customer:
            result['first_name'] = customer['first_name']
            result['last_name'] = customer['last_name']
            result['email'] = customer['email']
        return result

    def get_objects(self, **kwargs):
        if 'discount_id' in request.args:
            kwargs['discount_id'] = request.args['discount_id']
        if 'customer_id' in request.args:
            kwargs['customer_id'] = request.args['customer_id']

        query = self.model.query.filter_by(**kwargs)

        query = query.join(Customer)

        if 'q' in request.args and request.args['q']:
            q = request.args['q']
            q = "%"+q+"%"
            search_filters = (Customer.email.like(q),
                              Customer.first_name.like(q),
                              Customer.last_name.like(q))

            query = query.filter(or_(*search_filters))

        if 'o' in request.args:

            order_map = {'first_name': Customer.first_name,
                         'last_name': Customer.last_name,
                         'email': Customer.email}

            try:
                order_field = order_map[request.args['o']]
            except KeyError, e:
                raise BadRequest(_(u"Unsupported attribute value: o=%s" % e))

            ot = request.args.get('ot', 'asc')
            if ot == 'desc':
                order_field = order_field.desc()

            query = query.order_by(order_field)

        return query


@api_resource(discount, 'category', {'id': None})
class DiscountCategoryResource(ModelResource):
    model = Discount_x_Category

    method_decorators = {
        'post': [roles_required(admin_role)],
        'put': [roles_required(admin_role)],
        'delete': [roles_required(admin_role)]
    }

    validation = t.Dict({
        "discount_id": t.Int,
        "category_id":t.Int})

    def get(self, id=None):
        if id is None:
            response = self.gen_list_response()
            response = self.make_response(response)
        else:
            response = self.serialize(self.get_object(id))
            if response:
                response.update(self.get_params(response['category_id']))
        return jsonify_status_code(response)

    def make_response(self, response):
        for object in response["objects"]:
            object.update(self.get_params(object['category_id']))
        return response

    def get_params(self, category_id):
        result = dict()
        category = Category.query.filter_by(id=category_id).first()
        if category:
            category_dict = category.as_dict()
            result['name'] = category_dict['name']
            result['shops'] = category.shops
            result['images'] = category_dict['images']
            result['description'] = category_dict['description']
            result['order'] = category_dict['order']

        return result

    def get_objects(self, **kwargs):
        if 'discount_id' in request.args:
            kwargs['discount_id'] = request.args['discount_id']
        if 'category_id' in request.args:
            kwargs['category_id'] = request.args['category_id']

        query = self.model.query.filter_by(**kwargs)

        query = query.join(Category).outerjoin(Category._localized_class)

        if 'q' in request.args and request.args['q']:
            q = request.args['q']
            q = "%"+q+"%"

            LocalizedClass = Category._localized_class

            category_filters = (LocalizedClass.name.ilike(q),
                                LocalizedClass.description.ilike(q))

            subquery = db.session.query(LocalizedClass.parent_id) \
                            .filter(or_(*category_filters)).subquery()

            query = query.filter(Category.id.in_(subquery))

        if 'o' in request.args:
            order_map = {'name': Category._localized_class.name,
                         'created_at': Category.created_at,
                         'order': Category.order}

            try:
                order_field = order_map[request.args['o']]
            except KeyError, e:
                raise BadRequest(_(u"Unsupported attribute value: o=%s" % e))

            ot = request.args.get('ot', 'asc')
            if ot == 'desc':
                order_field = order_field.desc()

            query = query.order_by(order_field)

        return query

